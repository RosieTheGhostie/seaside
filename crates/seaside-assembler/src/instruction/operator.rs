use super::macros::*;
use core::str::FromStr;
use seaside_constants::{
    NumberFormat, Opcode,
    fn_codes::{
        Coprocessor0Fn, Coprocessor1Fn, Coprocessor1RegisterImmediateFn, RegisterImmediateFn,
        Special2Fn, SpecialFn,
    },
};

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum Operator {
    Special {
        r#fn: SpecialFn,
        condition: bool,
    },
    RegisterImmediate(RegisterImmediateFn),
    Jump,
    JumpAndLink,
    BranchEqual,
    BranchNotEqual,
    BranchLessEqualZero,
    BranchGreaterThanZero,
    AddImmediate,
    AddImmediateUnsigned,
    SetLessThanImmediate,
    SetLessThanImmediateUnsigned,
    AndImmediate,
    OrImmediate,
    XorImmediate,
    LoadUpperImmediate,
    Coprocessor0(Coprocessor0Fn),
    Coprocessor1 {
        r#fn: Coprocessor1Fn,
        fmt: NumberFormat,
        condition: bool,
    },
    Coprocessor1RegisterImmediate {
        r#fn: Coprocessor1RegisterImmediateFn,
        condition: bool,
    },
    Special2(Special2Fn),
    LoadByte,
    LoadHalf,
    LoadWordLeft,
    LoadWord,
    LoadByteUnsigned,
    LoadHalfUnsigned,
    LoadWordRight,
    StoreByte,
    StoreHalf,
    StoreWordLeft,
    StoreWord,
    StoreConditional,
    StoreWordRight,
    LoadLinked,
    LoadWordCoprocessor1,
    LoadDoubleCoprocessor1,
    StoreWordCoprocessor1,
    StoreDoubleCoprocessor1,
}

impl Operator {
    pub fn op_or_fn_code(&self) -> u8 {
        use Operator::*;
        match self {
            Special { r#fn, .. } => *r#fn as u8,
            RegisterImmediate(r#fn) => *r#fn as u8,
            Jump => Opcode::Jump as u8,
            JumpAndLink => Opcode::JumpAndLink as u8,
            BranchEqual => Opcode::BranchEqual as u8,
            BranchNotEqual => Opcode::BranchNotEqual as u8,
            BranchLessEqualZero => Opcode::BranchLessEqualZero as u8,
            BranchGreaterThanZero => Opcode::BranchGreaterThanZero as u8,
            AddImmediate => Opcode::AddImmediate as u8,
            AddImmediateUnsigned => Opcode::AddImmediateUnsigned as u8,
            SetLessThanImmediate => Opcode::SetLessThanImmediate as u8,
            SetLessThanImmediateUnsigned => Opcode::SetLessThanImmediateUnsigned as u8,
            AndImmediate => Opcode::AndImmediate as u8,
            OrImmediate => Opcode::OrImmediate as u8,
            XorImmediate => Opcode::XorImmediate as u8,
            LoadUpperImmediate => Opcode::LoadUpperImmediate as u8,
            Coprocessor0(r#fn) => *r#fn as u8,
            Coprocessor1 { r#fn, .. } => *r#fn as u8,
            Coprocessor1RegisterImmediate { r#fn, .. } => *r#fn as u8,
            Special2(r#fn) => *r#fn as u8,
            LoadByte => Opcode::LoadByte as u8,
            LoadHalf => Opcode::LoadHalf as u8,
            LoadWordLeft => Opcode::LoadWordLeft as u8,
            LoadWord => Opcode::LoadWord as u8,
            LoadByteUnsigned => Opcode::LoadByteUnsigned as u8,
            LoadHalfUnsigned => Opcode::LoadHalfUnsigned as u8,
            LoadWordRight => Opcode::LoadWordRight as u8,
            StoreByte => Opcode::StoreByte as u8,
            StoreHalf => Opcode::StoreHalf as u8,
            StoreWordLeft => Opcode::StoreWordLeft as u8,
            StoreWord => Opcode::StoreWord as u8,
            StoreConditional => Opcode::StoreConditional as u8,
            StoreWordRight => Opcode::StoreWordRight as u8,
            LoadLinked => Opcode::LoadLinked as u8,
            LoadWordCoprocessor1 => Opcode::LoadWordCoprocessor1 as u8,
            LoadDoubleCoprocessor1 => Opcode::LoadDoubleCoprocessor1 as u8,
            StoreWordCoprocessor1 => Opcode::StoreWordCoprocessor1 as u8,
            StoreDoubleCoprocessor1 => Opcode::StoreDoubleCoprocessor1 as u8,
        }
    }

    pub const fn new_special(r#fn: SpecialFn, condition: bool) -> Self {
        Self::Special { r#fn, condition }
    }

    pub const fn new_coprocessor_1(
        r#fn: Coprocessor1Fn,
        fmt: NumberFormat,
        condition: bool,
    ) -> Self {
        Self::Coprocessor1 {
            r#fn,
            fmt,
            condition,
        }
    }
}

impl FromStr for Operator {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s {
            "sll" => special!(ShiftLeftLogical),
            "movt" => special!(MoveConditional, true),
            "movf" => special!(MoveConditional, false),
            "srl" => special!(ShiftRightLogical),
            "sra" => special!(ShiftRightArithmetic),
            "sllv" => special!(ShiftLeftLogicalVariable),
            "srlv" => special!(ShiftRightLogicalVariable),
            "srav" => special!(ShiftRightArithmeticVariable),
            "jr" => special!(JumpRegister),
            "jalr" => special!(JumpAndLinkRegister),
            "movz" => special!(MoveZero),
            "movn" => special!(MoveNotZero),
            "syscall" => special!(SystemCall),
            "break" => special!(Break),
            "mfhi" => special!(MoveFromHigh),
            "mthi" => special!(MoveToHigh),
            "mflo" => special!(MoveFromLow),
            "mtlo" => special!(MoveToLow),
            "mult" => special!(Multiply),
            "multu" => special!(MultiplyUnsigned),
            "div" => special!(Divide),
            "divu" => special!(DivideUnsigned),
            "add" => special!(Add),
            "addu" => special!(AddUnsigned),
            "sub" => special!(Subtract),
            "subu" => special!(SubtractUnsigned),
            "and" => special!(And),
            "or" => special!(Or),
            "xor" => special!(Xor),
            "nor" => special!(Nor),
            "slt" => special!(SetLessThan),
            "sltu" => special!(SetLessThanUnsigned),
            "tge" => special!(TrapGreaterEqual),
            "tgeu" => special!(TrapGreaterEqualUnsigned),
            "tlt" => special!(TrapLessThan),
            "tltu" => special!(TrapLessThanUnsigned),
            "teq" => special!(TrapEqual),
            "tne" => special!(TrapNotEqual),
            "bltz" => register_immediate!(BranchLessThanZero),
            "bgez" => register_immediate!(BranchGreaterEqualZero),
            "tgei" => register_immediate!(TrapGreaterEqualImmediate),
            "tgeiu" => register_immediate!(TrapGreaterEqualImmediateUnsigned),
            "tlti" => register_immediate!(TrapLessThanImmediate),
            "tltiu" => register_immediate!(TrapLessThanImmediateUnsigned),
            "teqi" => register_immediate!(TrapEqualImmediate),
            "tnei" => register_immediate!(TrapNotEqualImmediate),
            "bltzal" => register_immediate!(BranchLessThanZeroAndLink),
            "bgezal" => register_immediate!(BranchGreaterEqualZeroAndLink),
            "j" => Self::Jump,
            "jal" => Self::JumpAndLink,
            "beq" => Self::BranchEqual,
            "bne" => Self::BranchNotEqual,
            "blez" => Self::BranchLessEqualZero,
            "bgtz" => Self::BranchGreaterThanZero,
            "addi" => Self::AddImmediate,
            "addiu" => Self::AddImmediateUnsigned,
            "slti" => Self::SetLessThanImmediate,
            "sltiu" => Self::SetLessThanImmediateUnsigned,
            "andi" => Self::AndImmediate,
            "ori" => Self::OrImmediate,
            "xori" => Self::XorImmediate,
            "lui" => Self::LoadUpperImmediate,
            "mfc0" => coprocessor_0!(MoveFromCoprocessor0),
            "mtc0" => coprocessor_0!(MoveToCoprocessor0),
            "eret" => coprocessor_0!(ErrorReturn),
            "add.s" => coprocessor_1!(<Single> Add),
            "sub.s" => coprocessor_1!(<Single> Subtract),
            "mul.s" => coprocessor_1!(<Single> Multiply),
            "div.s" => coprocessor_1!(<Single> Divide),
            "sqrt.s" => coprocessor_1!(<Single> SquareRoot),
            "abs.s" => coprocessor_1!(<Single> AbsoluteValue),
            "mov.s" => coprocessor_1!(<Single> Move),
            "neg.s" => coprocessor_1!(<Single> Negate),
            "round.w.s" => coprocessor_1!(<Single> RoundWord),
            "trunc.w.s" => coprocessor_1!(<Single> TruncateWord),
            "ceil.w.s" => coprocessor_1!(<Single> CeilingWord),
            "floor.w.s" => coprocessor_1!(<Single> FloorWord),
            "movt.s" => coprocessor_1!(<Single> MoveConditional, true),
            "movf.s" => coprocessor_1!(<Single> MoveConditional, false),
            "movz.s" => coprocessor_1!(<Single> MoveZero),
            "movn.s" => coprocessor_1!(<Single> MoveNotZero),
            "cvt.s.d" => coprocessor_1!(<Double> ConvertToSingle),
            "cvt.s.w" => coprocessor_1!(<Word> ConvertToSingle),
            "cvt.d.s" => coprocessor_1!(<Single> ConvertToDouble),
            "cvt.d.w" => coprocessor_1!(<Word> ConvertToDouble),
            "cvt.w.s" => coprocessor_1!(<Single> ConvertToWord),
            "cvt.w.d" => coprocessor_1!(<Double> ConvertToWord),
            "c.eq.s" => coprocessor_1!(<Single> CompareEqual),
            "c.lt.s" => coprocessor_1!(<Single> CompareLessThan),
            "c.le.s" => coprocessor_1!(<Single> CompareLessEqual),
            "mfc1" => coprocessor_1_register_immediate!(MoveFromCoprocessor1),
            "mtc1" => coprocessor_1_register_immediate!(MoveToCoprocessor1),
            "bc1f" => coprocessor_1_register_immediate!(BranchCoprocessor1Flag, false),
            "bc1t" => coprocessor_1_register_immediate!(BranchCoprocessor1Flag, true),
            "madd" => special_2!(MultiplyAdd),
            "maddu" => special_2!(MultiplyAddUnsigned),
            "mul" => special_2!(Multiply),
            "msub" => special_2!(MultiplySubtract),
            "msubu" => special_2!(MultiplySubtractUnsigned),
            "clz" => special_2!(CountLeadingZeroes),
            "clo" => special_2!(CountLeadingOnes),
            "lb" => Self::LoadByte,
            "lh" => Self::LoadHalf,
            "lwl" => Self::LoadWordLeft,
            "lw" => Self::LoadWord,
            "lbu" => Self::LoadByteUnsigned,
            "lhu" => Self::LoadHalfUnsigned,
            "lwr" => Self::LoadWordRight,
            "sb" => Self::StoreByte,
            "sh" => Self::StoreHalf,
            "swl" => Self::StoreWordLeft,
            "sw" => Self::StoreWord,
            "sc" => Self::StoreConditional,
            "swr" => Self::StoreWordRight,
            "ll" => Self::LoadLinked,
            "lwc1" => Self::LoadWordCoprocessor1,
            "ldc1" => Self::LoadDoubleCoprocessor1,
            "swc1" => Self::StoreWordCoprocessor1,
            "sdc1" => Self::StoreDoubleCoprocessor1,
            _ => return Err("unknown operator"),
        })
    }
}

impl From<Operator> for Opcode {
    fn from(value: Operator) -> Self {
        use Operator::*;
        match value {
            Special { .. } => Self::Special,
            RegisterImmediate(_) => Self::RegisterImmediate,
            Jump => Self::Jump,
            JumpAndLink => Self::JumpAndLink,
            BranchEqual => Self::BranchEqual,
            BranchNotEqual => Self::BranchNotEqual,
            BranchLessEqualZero => Self::BranchLessEqualZero,
            BranchGreaterThanZero => Self::BranchGreaterThanZero,
            AddImmediate => Self::AddImmediate,
            AddImmediateUnsigned => Self::AddImmediateUnsigned,
            SetLessThanImmediate => Self::SetLessThanImmediate,
            SetLessThanImmediateUnsigned => Self::SetLessThanImmediateUnsigned,
            AndImmediate => Self::AndImmediate,
            OrImmediate => Self::OrImmediate,
            XorImmediate => Self::XorImmediate,
            LoadUpperImmediate => Self::LoadUpperImmediate,
            Coprocessor0(_) => Self::Coprocessor0,
            Coprocessor1 { .. } | Coprocessor1RegisterImmediate { .. } => Self::Coprocessor1,
            Special2(_) => Self::Special2,
            LoadByte => Self::LoadByte,
            LoadHalf => Self::LoadHalf,
            LoadWordLeft => Self::LoadWordLeft,
            LoadWord => Self::LoadWord,
            LoadByteUnsigned => Self::LoadByteUnsigned,
            LoadHalfUnsigned => Self::LoadHalfUnsigned,
            LoadWordRight => Self::LoadWordRight,
            StoreByte => Self::StoreByte,
            StoreHalf => Self::StoreHalf,
            StoreWordLeft => Self::StoreWordLeft,
            StoreWord => Self::StoreWord,
            StoreConditional => Self::StoreConditional,
            StoreWordRight => Self::StoreWordRight,
            LoadLinked => Self::LoadLinked,
            LoadWordCoprocessor1 => Self::LoadWordCoprocessor1,
            LoadDoubleCoprocessor1 => Self::LoadDoubleCoprocessor1,
            StoreWordCoprocessor1 => Self::StoreWordCoprocessor1,
            StoreDoubleCoprocessor1 => Self::StoreDoubleCoprocessor1,
        }
    }
}
